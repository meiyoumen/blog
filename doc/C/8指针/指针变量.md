数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为指针变量。

## 定义指针变量

定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：

```
datatype *name;
或者
datatype *name = value;
```

==*表示这是一个指针变量==，datatype表示该指针变量所指向的数据的类型 。例如：

```
int *p1;
```

p1 是一个指向 int 类型数据的指针变量，至于 p1 究竟指向哪一份数据，应该由赋予它的值决定。
再如：

```
int a = 100;
int *p_a = &a;
```

在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。  
值得注意的是，p_a 需要的一个地址，a 前面必须要加取地址符&，否则是不对的。

和普通变量一样，指针变量也可以被多次写入，只要你想，随时都能够改变指针变量的值，请看下面的代码：

```
//定义普通变量
float a = 99.5, b = 10.6;
char c = '@', d = '#';
//定义指针变量
float *p1 = &a;
char *p2 = &c;
//修改指针变量的值
p1 = &b;
p2 = &d;
```

\*是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带*。  
而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上*，后边可以像使用普通变量一样来使用指针变量。

也就是说，==定义指针变量时必须带*，给指针变量赋值时不能带*==。

假设变量 a、b、c、d 的地址分别为 0X1000、0X1004、0X2000、0X2004，下面的示意图很好地反映了 p1、p2 指向的变化：
![image](https://note.youdao.com/yws/public/resource/40eb0f2a2bbd5ae78eb3afb88ee1c19d/xmlnote/7DA98F0CC9D54124B2277D6CA85CF6C7/7713)

需要强调的是，==p1、p2 的类型分别是float\*和char\*，而不是float和char==，它们是完全==不同的数据类型==，要引起注意

## 通过指针变量取得数据

指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：

```
*pointer;
```

==这里的*称为指针运算符==，用来取得某个地址上的数据，请看下面的例子：

```
#include <stdio.h>
int main(){
    int a = 15;
    int *p = &a;
    printf("%d, %d\n", a, *p);  //15 15 两种方式都可以输出a的值
    return 0;
}
```

假设 a 的地址是 0X1000，p 指向 a 后，p 本身的值也会变为 0X1000，*p 表示获取地址 0X1000 上的数据，也即变量 a 的值。从运行结果看，*p 和 a 是等价的。

上节我们说过，CPU 读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记

虽然通过 *p 和 a 获取到的数据一样，但它们的运行过程稍有不同：  
==a 只需要一次运算就能够取得数据，而 *p 要经过两次运算，多了一层“间接”==。

假设变量 a、p 的地址分别为 0X1000、0XF0A0，它们的指向关系如下图所示：

![image](https://note.youdao.com/yws/public/resource/40eb0f2a2bbd5ae78eb3afb88ee1c19d/xmlnote/7A6130AD6D614922B5D820A2F3AAC0C3/7711)

程序被编译和链接后，a、p 被替换成相应的地址。使用 *p 的话，要先通过地址 0XF0A0 取得变量 p 本身的值，这个值是变量 a 的地址，然后再通过这个值取得变量 a 的数据，前后共有两次运算；而使用 a 的话，可以通过地址 0X1000 直接取得它的数据，只需要一步运算。

==也就是说，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。==