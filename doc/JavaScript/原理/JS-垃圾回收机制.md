[TOC]
# 目录
## 内存生命周期
不管什么程序语言，内存生命周期基本是一致的：   

- 分配你所需要的内存
- 使用分配到的内存（读、写）
- 不需要时将其释放\归还

所有语言第二部分都是明确的。
第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。

## JavaScript 的内存分配

### JavaScript的根对象
GC的时候，从根对象开始遍历。在浏览器，根对象是 window；在 Node.js 中，是 global（或称为root）.
```js
// In Node.js
var a = 1
b =2
console.log(root === global) // true
console.log(root.a, root.b)  // undefined  2
```

Javascript 会找出不再使用的变量，不再使用意味着这个变量生命周期的结束。
Javascript 中存在两种变量：==全局变量==和==局部变量==

### 全局变理  
全局变量的声明周期会==一直持续==，直到页面卸载。

### 局部变量  
局部变量声明在函数中，它的声明周期从执行函数开始，直到函数执行结束。
局部变量会在堆或栈上被分配相应的空间以存储它们的值，函数执行结束，这些局部变量也不再被使用，它们所占用的空间也就被释放。、

但是有一种情况的局部变量不会随着函数的结束而被回收，那就是==局部变量被函数外部的变量所使=用=，其中一种==情况就是闭包==，因为在函数执行结束后，函数外部的变量依然指向函数内的局部变量，此时的局部变量依然在被使用，所以也就不能够被回收

举例说明：


```js
unction func1 () {
      const obj = {}
}

function func2 () {
      const obj = {}
      return obj
}

const a = func1()
const b = func2()
```

func1 执行时为 obj 分配了一块内存，但是随着函数执行结束，obj占用的空间也就被释放了.

func2 执行时，也为 obj 分配了内存，但是由于 ==obj 最终被返回赋值给了 b 导致其依然被使用==，所以 func2 中的 obj ==占用的内存不会被释放==

### 值的初始化
为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。


```js
var n = 123;        // 给数值变量分配内存
var s = "azerty";   // 给字符串分配内存

var o = {           // 给对象及其包含的值分配内存
  a: 1,
  b: null
}; 

// 给数组及其包含的值分配内存（就像对象一样）
var a = [1, null, "abra"]; 

function f(a){      // 给函数（可调用的对象）分配内存
  return a + 2;
} 

// 函数表达式也能分配一个对象
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);
```

### 通过函数调用分配内存
有些函数调用结果是分配对象内存：

```js
var d = new Date(); // 分配一个 Date 对象

var e = document.createElement('div'); // 分配一个 DOM 元素
```

有些方法分配新变量或者新对象：

```js
var s = "azerty";
var s2 = s.substr(0, 3); // s2 是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。

var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2); 
// 新数组有四个元素，是 a 连接 a2 的结果
```

## 垃圾回收方法
根据 Wiki 的定义，垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。

直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。

这个时候，不仅自己的程序无法正常运行，连其他程序也会受到影响。好比生物只有出生没有死亡，地球总有被撑爆的一天。

所以，在计算机中，我们需要垃圾回收。需要注意的是，定义中的“自动”的意思是语言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作失当，JavaScript 中依旧会出现内存溢出的情况。

==垃圾回收算法主要依赖于引用的概念==。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。

例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

### 1. 引用计数垃圾收集
当对象被引用次数为0时，就被回收。潜在的一个问题是：循环引用时，两个对象都至少被引用了一次，将不能自动被回收。所以导致，我们常讲的内存泄露。


```js
// 示例1
var o = { 
  a: {
    b:2
  }
}; 
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”的原始引用o被o2替换了

var oa = o2.a; // 引用“这个对象”的a属性
// 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 最初的对象现在已经是零引用了
           // 他可以被垃圾回收了
           // 然而它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
           
           
// 示例2
var a = {t: 1}; // 对象 `{t: 1}` （以下简称obj）被引用一次
var b = a; // obj 被引用两次
a = null; // obj 现在为1次
b = null; // obj 现在为0次，可回收

// 循环引用
function fn() {
    var a = {};
    var b = {};
    a.b = b;
    b.a = a;
}

fn();
```

- 限制：循环引用
该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。  

它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。

然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。


```
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```

### 2. 标记-清除算法
这是当前主流的GC算法，V8里面就是用这种。当对象，无法从根对象沿着引用遍历到，即不可达（unreachable），进行清除。对于上面的例子，fn() 里面的 a 和 b 在函数执行完毕后，就不能通过外面的上下文进行访问了，所以就可以清除了。  

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

==这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）==。

垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。


这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。


==从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法==。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，比如标记-整理方法。并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

标记清除有一个问题，就是在清除之后，==内存空间是不连续的，即出现了内存碎片==。  
如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。计算机中的很多做法都是互相妥协的结果，哪有什么十全十美的事儿呢。


- 循环引用不再是问题了
在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。
- 限制: 那些无法从根对象查询到的对象都将被清除
尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。

## V8

### chrome内存限制
- 存在限制  
Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB），这也就意味着将无法直接操作一些大内存对象。这很令人匪夷所思，因为很少有其他语言会限制内存的使用

- 为何限制  
V8之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因则是由于V8的垃圾回收机制的限制。由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。==若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上==。这样浏览器将在1s内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响

- 突破限制  
当然这个限制是可以打开的，类似于JVM，我们通过在启动node时可以传递--max-old-space-size或--max-new-space-size来调整内存限制的大小，前者确定老生代的大小，单位为MB，后者确定新生代的大小，单位为KB。这些配置只在V8初始化时生效，一旦生效不能再改变


### V8的堆构成
V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：
- 新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁
- 老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里
- 老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针
- 大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象
- 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区
- Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单

每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，其他区的内存页都是1MB大小，而且按照1MB对齐。内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。

另外每个内存页还有一个单独分配在另外内存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收

### V8的GC机制
自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。

所以，V8采用了一种代回收的策略，将内存分为两个生代：==新生代（new generation）和老生代（old generation）==。

```js
// 循环引用
function fn() {
    var a = {};
    var b = {};
    a.b = b;
    b.a = a;
}

fn();
```

对于上面的例子，fn() 里面的 a 和 b 在函数执行完毕后，就不能通过外面的上下文进行访问了，所以就可以清除了。

## V8引擎的垃圾回收
- [Node.js内存管理和V8垃圾回收机制](https://zhuanlan.zhihu.com/p/72380507)
- [深入理解V8的垃圾回收原理](https://www.jianshu.com/p/b8ed21e8a4fb)
- [聊聊V8引擎的垃圾回收](https://juejin.im/post/5ad3f1156fb9a028b86e78be)