<meta charset="UTF-8">
<script>
  /**
   函数防抖（debounce）
      当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间

   函数节流（throttle）
      预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期

   函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。
   比如如下的情况：
     window对象的resize、scroll事件
     拖拽时的mousemove事件
     文字输入、自动完成的keyup事件

   区别
      可以拿我们平时坐电梯为例来形象地表述二者的区别
      函数防抖：如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。
      函数节流 ：保证如果电梯第一个人进来后，10秒后准时运送一次，这个时间从第一个人上电梯开始计时，不等待，如果没有人，则不运行

   相同点：
      都可以通过使用 setTimeout 实现。
      目的都是，降低回调执行频率。节省计算资源。

   不同点：
     函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。
     函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。
     函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。


   常见应用场景
   函数防抖的应用场景
     连续的事件，只需触发一次回调的场景有：
       搜索框搜索输入。只需用户最后一次输入完，再发送请求
       手机号、邮箱验证输入检测
       窗口大小Resize。只需##窗口调整完成后，计算窗口大小。防止重复渲染。

   函数节流的应用场景
      间隔一段时间执行一次回调的场景有：
       滚动加载，加载更多或滚到底部监听
       谷歌搜索框，搜索联想功能
       高频点击提交，表单重复提交

   demo
   https://juejin.im/post/5d29abe3e51d45777b1a3e45
   https://juejin.im/post/5be2a3f7e51d455e041a4b8e
   https://juejin.im/post/5b7b88d46fb9a019e9767405
   https://github.com/yygmind/blog/issues/39 深入理解
   */
</script>
