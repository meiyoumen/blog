- 节点(Vertex) 与 边（Edge）
- 图的表示： 邻接表 和 邻接矩阵
    - 这里可以分为 有向图 和无向图
        - 无向图是一种特殊的有向图
    - 有权图 和 无权图

图的遍历： DFS BFS 常见可以解决的问题有： 联通分量 Flood Fill 寻路 走迷宫 迷宫生成 无权图的最短路径 环的判断
最小生成树问题（Minimum Spanning Tree） Prim Kruskal
最短路径问题(Shortest Path) Dijkstra Bellman-Ford
拓扑排序(Topological sorting)

![image](https://segmentfault.com/img/bVTNFS?w=1300&h=818)

## 有向图 / 无向图
- 无向图(边没有方向)
- 有向图(边有方向)

![image](https://user-gold-cdn.xitu.io/2018/8/30/1658993ec8ffddd7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
无向图

![image](https://user-gold-cdn.xitu.io/2018/8/30/165899407a74e442?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
有向图

## 图的存储结构
- 邻接矩阵
- 邻接表
- 十字链表
- 邻接多重表


## 邻接表
表示一个图，最常用的方式是邻接表。每个顶点都有一个记录着与它所相邻顶点的表。

可以使用一个数组或者 HashMap 来建立一个邻接表，它存储这所有的顶点。  
每个顶点都有一个列表（可以是数组、链表、集合等数据结构），存放着与其相邻的顶点。


例如上面的图，对于顶点 a，与之相邻的有顶点 b，同时也是自环；而顶点 b 则有指向顶点 c 的边，如此类推：


```
a -> { a b }
b -> { c }
c -> { d }
d -> { b c }
```

和想象中的一样，如果想知道一个顶点是否连接着其他顶点，就必须遍历（顶点的）整个列表。
>在邻接表中查询两个顶点是否相连的时间复杂度是 O(n)，n 为顶点的数量，因此也可以表示为 O(|V|)。

那空间复杂度呢？
>利用邻接表存储一个图的空间复杂度是 O(n)，n 为顶点数量与边数量之和，因此也可以表示为 O(|V| + |E|)。

### 基于 HashMap 实现的邻接表


```
const graph = {
  a：[ 'a'，'b' ]，
  b：[ 'c' ]，
  c：[ 'd' ]，
  d：[ 'b'，'c' ]
};
```

图通常需要实现以下两种操作：

- 添加或删除顶点。
- 添加或删除边。

添加或删除一个顶点需要更新邻接表。  
假设需要删除顶点 b。我们不但需要 delete graph['b']，还需要删除顶点 a 与顶点 d 的邻接数组中的引用。

每当移除一个顶点，都需要遍历整个邻接表，因此时间复杂度是 O(|V| + |E|)。  


有更好的实现方式吗？稍后再回答这问题。首先让我们以更面向对象的方式实现邻接表，之后切换（邻接表的底层）实现将更容易。


## 广度优先搜索(BFS) - 图的搜索 Breadth First Search in a graph
![image](https://user-gold-cdn.xitu.io/2018/7/23/164c76f095c3bd34?imageslim)


## 深度优先搜索 (DFS) -图的搜索 Depth First Search in a graph
![image](https://user-gold-cdn.xitu.io/2018/7/23/164c76f0943a8a2b?imageslim)

## 图的时间与空间复杂度


&nbsp;       | 邻接表  | 邻接矩阵
---|---|---
空间复杂度   |    O(\|V\|+ \|E\|)       |    O(\|V\|²)
添加顶点度   |    O(1)                  | 	 O(\|V\|²)
移除顶点度   |    O(\|V\| + \|E\|)度    |    O(\|V\|)²
添加边       |    O(1)	                |    O(1)
移除边(基于 Array 实现)             |    	O(\|E\|)	    |    O(1)
移除边 (基于 HashSet 实现)          |       O(1)		    |    O(1
获取相邻的顶点                      |    	O(\|E\|)		|    O(\|V\|)
判断是否相邻 (基于 Array 实现)      |    	O(\|E\|)		|    O(1)
判断是否相邻 (基于 HashSet 实现)    |    	O(1)		    |    O(1)

正如上表所示，邻接表中几乎所有的操作方法都是更快的。  
邻接矩阵比邻接表性能更高的方法只有一处：检查顶点是否与其他顶点相邻，然而使用 HashSet 而不是 Array 实现邻接表的话，也能在恒定时间内获取结果 :)


参考：  
https://juejin.im/post/5b5bb171f265da0f5d4cdf33

-初学者应该了解的数据结构：Array、HashMap 与 List
https://www.zcfy.cc/article/data-structures-for-beginners-arrays-hashmaps-and-lists