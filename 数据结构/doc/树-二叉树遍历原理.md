## 二叉树遍历原理
==二叉树的遍历：是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次==。

这里有两个关键词：==访问和次序==。

访问其实是要根据实际的需要来确定具体做什么，比如对每个结点进行相关计算，输出打印等。它算作是一个抽象操作。

二叉树的遍历次序不同于线性结构，最多也就是从头到尾、循环和双向等简单的遍历方式。树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。

## 二叉树遍历方法
二叉树的遍历方式可以有很多，如果我们限制从左到右的顺序，就主要分为四种：

- 前序遍历
- 中序遍历
- 后序遍历
- 层序遍历

![image](https://note.youdao.com/yws/public/resource/974c502c0eb250bc7e4d052c76f971d8/xmlnote/13D6CE2C27D64BE1880201261A5621A4/14522)



前序遍历 | 中序遍历 | 后序遍历
---|------|---
1. 访问根节点     | 1. 中序遍历左子树 |  1. 后序遍历左子树
2. 前序遍历左子树 | 2. 访问根节点     |  1. 后序遍历右子树
3. 前序遍历右子树 | 3. 中序遍历右子树 |  1. 访问根节点

总结：
==一句话总结：先序(根->左->右)，中序(左->根->右)，后序(左->右->根)==

1. 前序遍历
若二叉树为空，则空操作返回，否则==先访问根结点==，然后==前序遍历左子树==，再前==序遍历右子==树。  
如下图遍历顺序为：A B D G H C E I F。  
![image](https://user-gold-cdn.xitu.io/2018/6/20/1641c591b79998b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


2. 中序遍历

若二叉树为空，则空操作返回，否则从==根结点开始（注意并不是先访问根结点）==，中序遍历根结点左子树，然后访问根结点，最后中序遍历右子树。  
如下图遍历顺序为：G D H B A E I C F。  
![image](https://user-gold-cdn.xitu.io/2018/6/20/1641c591b78015a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


3. 后序遍历  
若二叉树为空，则空操作返回，==否则从左到右先叶子后结点的方式遍历访问左右子树==，最后是访问根结点，如下图遍历顺序为：G H D B I E F C A。  
![image](https://user-gold-cdn.xitu.io/2018/6/20/1641c591b791e58b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

4. 层序遍历  
若二叉树为空，则空操作返回，否则从树的第一层开始，也就是从根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。
如下图遍历顺序为：A B C D E F G H I。

![image](https://user-gold-cdn.xitu.io/2018/6/20/1641c591b7c801b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

我们提到的四种遍历方式，其实都是在把树种的结点编程某种意义上的线性序列，这样给程序执行带来了好处。

层序遍历很好理解：
- 就是逐层遍历，每层从左到右逐个遍历；
- 前序、中序、后序遍历最根本的区别就是双亲结点的访问时机：
    - 前序是先访问双亲结点，然后左孩子，最后右孩子；
    - 中序是左孩子，双亲，右孩子；
    - 后序是左孩子、右孩子最后双亲结点。


树的定义就使用了递归这一方式，当然，对树的遍历也是使用递归（注意递归算法一定要有结束递归的标志），关于二叉树遍历的算法，就不再详细描述了。

## 前驱和后继
==前驱和后继要结合遍历顺序来==谈，某个节点在特定遍历顺序下序列中的前后两个节点就是它的前驱和后继
如二叉树：

```
      1 
  2        3
4  5    6   7
```

以结点2为例，
- 前序遍历下，遍历序列为1 2 4 5 3 6 7 故前驱和后继为1、4
- 中序遍历下，遍历序列为4 2 5 1 6 3 7 故前驱和后继为4、5
- 后续遍历下，遍历序列为4 5 2 6 7 3 1 故前驱和后继为5、6

## 推导遍历结果
有一种题目是为了考察你对二叉树遍历的掌握程度，会这样出题：已知一棵二叉树的前序遍历顺序是ABCDEF，中序遍历顺序是CBAEDF，请问这棵树的后序遍历是什么？

对于这样的题目，如果真正了解各种遍历规则，其实是不难的。

三种遍历都是从根结点开始，前序遍历是先打印再递归左和右，  
所有前序遍历序列为ABCDEF，  
第一个字母A就是根结点；  
再由中序遍历序列CBAEDF，  
可以只带C和B是A的左子树上的结点，E、D、F是A的右子树上的结点，  
我们可以得到以下这样的图：  
![image](https://user-gold-cdn.xitu.io/2018/6/20/1641c591b7a6b55b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

然后再看前序序列中的C和B，先B再C，所以B应该是A的左孩子，C就只能说B的孩子了，至于C是B的左还是右孩子，再看中序序列CBAEDF，C在B之前打印，说明C是B的左孩子，如图：  
![image](https://user-gold-cdn.xitu.io/2018/6/20/1641c591b7cded71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

再看前序中的E、D、F，他们的顺序是ABCDEF，意味着D是A的右孩子，E和F是D的子孙（注意，他们中有一个不一定是孩子，还可能是孙子）。再看中序序列是CBAEDF，E在D的左侧，F在右侧，所以E是D的左孩子，F是D的右孩子，如图：  
![image](https://user-gold-cdn.xitu.io/2018/6/20/1641c591d8a3c110?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

为了避免推导失误，我们最好自己再按此树推导一遍前序和中序遍历序列。根据二叉树结构图，轻松得到后序遍历为CBEFDA。


### 这里我们可以得到两个二叉树遍历的性质：

- 已知==前序==遍历序列和==中序==遍历序列，可以唯一确定一棵二叉树；
- 已知==后序==遍历序列和==中序遍==历序列，可以唯一确定一棵二叉树；

==注意：已知前序和后序遍历，是不能确定一棵二叉树的。==
