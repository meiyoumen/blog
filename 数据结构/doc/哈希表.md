## 哈希是什么？

散列（hashing）是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列。旧译哈希（误以为是人名而采用了音译）。它也常用作一种资讯安全的实作方法，由一串资料中经过散列算法（Hashing algorithms）计算出来的资料指纹（data fingerprint），经常用来识别档案与资料是否有被窜改，以保证档案与资料确实是由原创者所提供。      ----Wikipedia

## 定义
Hash（哈希），又称“散列”。

散列（hash）英文原意是“混杂”、“拼凑”、“重新表述”的意思。

在某种程度上，散列是与排序相反的一种操作，排序是将集合中的元素按照某种方式比如字典顺序排列在一起，而散列通过计算哈希值，打破元素之间原有的关系，使集合中的元素按照散列函数的分类进行排列。

在介绍一些集合时，我们总强调需要重写某个类的 equlas() 方法和 hashCode() 方法，确保唯一性。
这里的 hashCode() 表示的是对当前对象的唯一标示。计算 hashCode 的过程就称作 哈希。

## 为什么要有 Hash
我们通常使用数组或者链表来存储元素，一旦存储的内容数量特别多，需要占用很大的空间，而且在查找某个元素是否存在的过程中，数组和链表都需要挨个循环比较，而通过 哈希 计算，可以==大大减少比较次数==。  
![image](https://img-blog.csdn.net/20161026174147384)
![image](https://segmentfault.com/img/bVblUZo?w=624&h=522)


### 举个栗子：

现在有 4 个数 {2,5,9,13}，需要查找 13 是否存在。

#### 1. 使用数组存储，需要新建个数组 new int[]{2,5,9,13}，然后需要写个循环遍历查找：

```js
int[] numbers = new int[]{2,5,9,13};
    for (int i = 0; i < numbers.length; i++) {
        if (numbers[i] == 13){
            System.out.println("find it!");
            return;
        }
    }
```
这样需要遍历 4 次才能找到，时间复杂度为 O(n)。

#### 2.而假如存储时先使用哈希函数进行计算，这里我随便用个函数：

```
H[key] = key % 3;
```
四个数 {2,5,9,13} 对应的哈希值为：

```
H[2] = 2 % 3 = 2;
H[5] = 5 % 3 = 2;
H[9] = 9 % 3 = 0;
H[13] = 13 % 3 = 1;
```
然后把它们存储到对应的位置。

当要查找 13 时，只要先使用哈希函数计算它的位置，然后去那个位置查看是否存在就好了，本例中只需查找一次，时间复杂度为 O(1)。

因此可以发现，哈希 其实是随机存储的一种优化，先进行分类，然后查找时按照这个对象的分类去找。 

哈希通过一次计算大幅度缩小查找范围，自然比从全部数据里查找速度要快。  

比如你和我一样是个剁手族买书狂，家里书一大堆，如果书存放时不分类直接摆到书架上（数组存储），找某本书时可能需要脑袋从左往右从上往下转好几圈才能发现；如果存放时按照类别分开放，技术书、小说、文学等等分开（按照某种哈希函数计算），找书时只要从它对应的分类里找，自然省事多了。



## hash函数
哈希表（hash table ）是一种根据关键字直接访问内存存储位置的数据结构，通过哈希表，数据元素的存放位置和数据元素的关键字之间建立起某种对应关系，建立这种对应关系的函数称为哈希函数

哈希的过程中需要使用哈希函数进行计算。  
哈希函数是一种映射关系，根据数据的关键词 key ，通过一定的函数关系，计算出该元素存储位置的函数。  
表示为：  

```
address = H [key]
```


## 哈希表的构造方法

假设要存储的数据元素个数是n，设置一个长度为m(m > n)的连续存储单元，分别以每个数据元素的关键字Ki(0<=i<=n-1)为自变量，通过哈希函数hash(Ki)，把Ki映射为内存单元的某个地址hash(Ki),并将数据元素存储在内存单元中

从数学的角度看，哈希函数实际上是关键字到内存单元的映射，因此我们希望通过哈希函数通过尽量简单的运算使得哈希函数计算出的花溪地址尽量均匀的背影射到一系列的内存单元中，构造哈希函数有三个要点：
- （1）运算过程要尽量简单高效，以提高哈希表的插入和检索效率；
- （2）哈希函数应该具有较好的散列型，以降低哈希冲突的概率；
-  (3)，哈希函数应具有较大的压缩性，以节省内存。

以下有三种常用方法：

- 直接地址法：以关键字的某个线性函数值为哈希地址，可以表示为hash(K)=aK+C;优点是不会产生冲突，缺点是空间复杂度可能会较高，适用于元素较少的情况
    
    - 取关键字或关键字的某个线性函数值为散列地址。
    - 即 H(key) = key 或 H(key) = a*key + b，其中a和b为常数。  
    ![image](https://img-blog.csdn.net/20161026171706654)

- 除留余数法：
     - 取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。
    - 即 H(key) = key % p, p < m。  
    ![image](https://img-blog.csdn.net/20161026171807417)

它是由数据元素关键字除以某个常数所留的余数为哈希地址，该方法计算简单，适用范围广，是经常使用的一种哈希函数，可以表示为：
```
hash(K=K mod C;该方法的关键是常数的选取，一般要求是接近或等于哈希表本身的长度，研究理论表明，该常数选素数时效果最好
```



- 数字分析法：该方法是取数据元素关键字中某些取值较均匀的数字来作为哈希地址的方法，这样可以尽量避免冲突，但是该方法只适合于所有关键字已知的情况，对于想要设计出更加通用的哈希表并不适用
    - 当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址。
    - 仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。  
    ![image](https://img-blog.csdn.net/20161026172017748)

- 平方求和法：对当前字串转化为Unicode值，并求出这个值的平方，去平方值中间的几位为当前数字的hash值，具体取几位要取决于当前哈希表的大小。
    - 先计算出关键字值的平方，然后取平方值中间几位作为散列地址。
    - 随机分布的关键字，得到的散列地址也是随机分布的。  
    ![image](https://img-blog.csdn.net/20161026171618181)

- 分段求和法：根据当前哈希表的位数把所要插入的数值分成若干段，把若干段进行相加，舍去调最高位结果就是这个值的哈希值。


## 哈希冲突的解决方案
在构造哈希表时，存在这样的问题：对于两个不同的关键字，通过我们的哈希函数计算哈希地址时却得到了相同的哈希地址，我们将这种现象称为哈希冲突

clipboard.png

哈希冲突主要与两个因素有关:  
（1）填装因子，填装因子是指哈希表中已存入的数据元素个数与哈希地址空间的大小的比值，a=n/m ; a越小，冲突的可能性就越小，相反则冲突可能性较大；但是a越小空间利用率也就越小，a越大，空间利用率越高，为了兼顾哈希冲突和存储空间利用率，通常将a控制在0.6-0.9之间，而.net中的HashTable则直接将a的最大值定义为0.72 （虽然微软官方MSDN中声明HashTable默认填装因子为1.0，但实际上都是0.72的倍数），

（2）与所用的哈希函数有关，如果哈希函数得当，就可以使哈希地址尽可能的均匀分布在哈希地址空间上，从而减少冲突的产生，但一个良好的哈希函数的得来很大程度上取决于大量的实践，不过幸好前人已经总结实践了很多高效的哈希函数，可以参考大神Lucifer文章：数据结构：HahTable： http://www.cnblogs.com/lucife...


### 1）开放定址法


```
Hi=(H(key) + di) MOD m i=1,2,...k(k<=m-1) 
其中H(key)为哈希函数；m为哈希表表长；di为增量序列。有3中增量序列： 
1）线性探测再散列：di=1,2,3,...,m-1 
2）二次探测再散列：di=1^2,-1^2,2^2,-2^2,....+-k^2(k<=m/2) 
3）伪随机探测再散列：di=伪随机数序列
```

- 缺点：  
我们可以看到一个现象：当表中i,i+1,i+2位置上已经填有记录时，下一个哈希地址为i,i+1,i+2和i+3的记录都将填入i+3的位置，这种在处理冲突过程中发生的两个第一个哈希地址不同的记录争夺同一个后继哈希地址的现象称为“二次聚集”，即在处理同义词的冲突过程中又添加了非同义词的冲突。但另一方面，用线性探测再散列处理冲突可以保证做到：只要哈希表未填满，总能找到一个不发生冲突的地址Hk。而二次探测再散列只有在哈希表长m为形如4j+3（j为整数）的素数时才可能。即开放定址法会造成二次聚集的现象，对查找不利。



### 2)再哈希法
Hi = RHi（key），i=1,2,...k RHi均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到不发生冲突为止。这种方法不易产生聚集，但是增加了计算时间。

- 缺点：增加了计算时间。

### 3)链地址法（拉链法）

将所有关键字为同义词的记录存储在同一线性链表中。

优点:
1. 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
2. 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
3. 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
4. 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点

缺点：  
拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度  

做法：

将所有关键字为同义词的结点链接在同一个单链表中。
若选定的散列表长度为 m，则可将散列表定义为一个由 m 个头指针组成的指针数组 T[0..m-1] 。
凡是散列地址为 i 的结点，均插入到以 T[i] 为头指针的单链表中。 
T 中各分量的初值均应为空指针。
在拉链法中，装填因子 α 可以大于 1，但一般均取 α ≤ 1。  
![image](https://img-blog.csdn.net/20161026174615667)

### 4)建立一个公共溢出区
假设哈希函数的值域为[0,m-1]，则设向量HashTable[0...m-1]为基本表，每个分量存放一个记录，另设立向量OverTable[0....v]为溢出表。所有关键字和基本表中关键字为同义词的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。

## 几种常见的hash函数

### DJBHash

```
unsigned int DJBHash(char *str)    
{    
    unsigned int hash = 5381;    
     
    while (*str){    
        hash = ((hash << 5) + hash) + (*str++); /* times 33 */    
    }    
    hash &= ~(1 << 31); /* strip the highest bit */    
    return hash;    
}
```



```js
// javascript版

function DJBHash(str)    {    
    var hash = 5381;   
    var len = str.length , i = 0
     
    while (len--){    
        hash = (hash << 5) + hash + str.charCodeAt(i++); /* times 33 */    
    }    
    hash &= ~(1 << 31); /* strip the highest bit */    
    return hash;    
}
```




```js

// JS
// Justin Sobel写的一个位操作的哈希函数。原版

function JSHash(str)  {  
      var hash = 1315423911;  
      for(var i = 0; i < str.length; i++)  {  
         hash ^= ((hash << 5) + str.charCodeAt(i) + (hash >> 2));  
      }  
      return hash;  
}
```

### PJW
该散列算法是基于贝尔实验室的彼得J温伯格的的研究。在Compilers一书中（原则，技术和工具），建议采用这个算法的散列函数的哈希方法。


```js
function PJWHash( str)  {  
      var BitsInUnsignedInt = 4 * 8;  
      var ThreeQuarters     =  (BitsInUnsignedInt  * 3) / 4;  
      var OneEighth         = (BitsInUnsignedInt / 8);  
      var HighBits          = (0xFFFFFFFF) << (BitsInUnsignedInt - OneEighth);  
      var hash              = 0;  
      var test              = 0;  
      for(var i = 0; i < str.length; i++)  {  
         hash = (hash << OneEighth) + str.charCodeAt(i);  
         if((test = hash & HighBits)  != 0)  
         {  
            hash = (( hash ^ (test >> ThreeQuarters)) & (~HighBits));  
         }  
      }  
      return hash;  
}
```
### ELF
和PJW很相似，在Unix系统中使用的较多。


```js
public long ELFHash(String str)  
   {  
      long hash = 0;  
      long x    = 0;  
      for(int i = 0; i < str.length(); i++)  
      {  
         hash = (hash << 4) + str.charAt(i);  
         if((x = hash & 0xF0000000L) != 0)  
         {  
            hash ^= (x >> 24);  
         }  
         hash &= ~x;  
      }  
      return hash;  
   }
```

### BKDR
这个算法来自Brian Kernighan 和 Dennis Ritchie的 The C Programming Language。这是一个很简单的哈希算法,使用了一系列奇怪的数字,形式如31,3131,31...31,看上去和DJB算法很相似。

```js
public long BKDRHash(String str)  
   {  
      long seed = 131; // 31 131 1313 13131 131313 etc..  
      long hash = 0;  
      for(int i = 0; i < str.length(); i++)  
      {  
         hash = (hash * seed) + str.charAt(i);  
      }  
      return hash;  
   }
```

### SDBM
这个算法在开源的SDBM中使用，似乎对很多不同类型的数据都能得到不错的分布。

```js
public long SDBMHash(String str)  
   {  
      long hash = 0;  
      for(int i = 0; i < str.length(); i++)  
      {  
         hash = str.charAt(i) + (hash << 6) + (hash << 16) - hash;  
      }  
      return hash;  
   }
```

## DJB
这个算法是Daniel J.Bernstein 教授发明的，是目前公布的最有效的哈希函数。


```js
public long DJBHash(String str)  
   {  
      long hash = 5381;  
      for(int i = 0; i < str.length(); i++)  
      {  
         hash = ((hash << 5) + hash) + str.charAt(i);  
      }  
      return hash;  
   }
```

### DEK
由伟大的Knuth在《编程的艺术 第三卷》的第六章排序和搜索中给出。


```js
public long DEKHash(String str)  
   {  
      long hash = str.length();  
      for(int i = 0; i < str.length(); i++)  
      {  
         hash = ((hash << 5) ^ (hash >> 27)) ^ str.charAt(i);  
      }  
      return hash;  
   }
```

   
### AP
由Arash Partow贡献的一个哈希函数，继承了上面以旋转以为和加操作


```js
public long APHash(String str)  
{  
      long hash = 0xAAAAAAAA;  
      for(int i = 0; i < str.length(); i++)  
      {  
         if ((i & 1) == 0)  
         {  
            hash ^= ((hash << 7) ^ str.charAt(i) * (hash >> 3));  
         }  
         else  
         {  
            hash ^= (~((hash << 11) + str.charAt(i) ^ (hash >> 5)));  
         }  
      }  
      return hash;  
   }
```


- 其中数据1为100000个字母和数字组成的随机串哈希冲突个数。
- 数据2为100000个有意义的英文句子哈希冲突个数。
- 数据3为数据1的哈希值与 1000003(大素数)求模后存储到线性表中冲突的个数。
- 数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。

经过比较，得出以上平均得分。平均数为平方平均数。可以发现，
- ==BKDRHash无论是在实际效果还是编码实现中==，效果都是最突出的。
- ==APHash==也是较为优秀的算法。
- DJBHash,JSHash,RSHash与SDBMHash各有千秋。
- PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。

## 哈希的应用

- 哈希表
- 分布式缓存

### 哈希表（散列表）

哈希表（hash table）是哈希函数最主要的应用。  
哈希表是实现关联数组（associative array）的一种数据结构，广泛应用于实现数据的快速查找。
![image](https://img-blog.csdn.net/20161027004004320)

用哈希函数计算关键字的哈希值（hash value）,通过哈希值这个索引就可以找到关键字的存储位置，即桶（bucket）。  
哈希表不同于二叉树、栈、序列的数据结构一般情况下，在哈希表上的插入、查找、删除等操作的时间复杂度是 O(1)。

查找过程中，关键字的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。  
因此，影响产生冲突多少的因素，也就是影响查找效率的因素。 
影响产生冲突多少有以下三个因素：

- 哈希函数是否均匀；
- 处理冲突的方法；
- 哈希表的加载因子。

哈希表的加载因子和容量决定了在什么时候桶数（存储位置）不够，需要重新哈希。
加载因子太大的话桶太多，遍历时效率变低；太大的话频繁rehash，导致性能降低。  
所以加载因子的大小需要结合时间和空间效率考虑。

==在 HashMap 中的加载因子为 0.75，即四分之三==。

### 分布式缓存  
网络环境下的分布式缓存系统一般基于一致性哈希（Consistent hashing）。简单的说，一致性哈希将哈希值取值空间组织成一个虚拟的环，各个服务器与数据关键字K使用相同的哈希函数映射到这个环上，数据会存储在它顺时针“游走”遇到的第一个服务器。可以使每个服务器节点的负载相对均衡，很大程度上避免资源的浪费。  

在动态分布式缓存系统中，哈希算法的设计是关键点。使用分布更合理的算法可以使得多个服务节点间的负载相对均衡，可以很大程度上避免资源的浪费以及部分服务器过载。 使用带虚拟节点的一致性哈希算法，可以有效地降低服务硬件环境变化带来的数据迁移代价和风险，从而使分布式缓存系统更加高效稳定。


## 补充一个小知识点
v8引擎中的数组 arr = [1,2,3,4,5] 或 new Array(100) 我们都知道它是开辟了一块连续的空间去存储，而arr = [] , arr[100000] = 10 这样的操作它是使用的散列，因为这种操作如果连续开辟100万个空间去存储一个值，那么显然是在浪费空间。

作者：拭心 
原文：https://blog.csdn.net/u011240877/article/details/52940469 

作者：司徒正美 
原文：https://segmentfault.com/a/1190000013132249
http://www.voidcn.com/article/p-ffbyqaps-bse.html


https://segmentfault.com/a/1190000017578404

## 哈希树
https://segmentfault.com/a/1190000013010524