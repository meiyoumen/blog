- 队列的抽象数据类型
- 顺序队列的设计与实现
- 链式队列的设计与实现
- 队列应用的简单举例
- 优先队列的设置与实现双链表实现

## 分类
优先队列分为两类：

- 最小优先队列
- 最大优先队列

### 最小优先队列
把优先级的值最小的元素被放置到队列的最前面（代表最高的优先级）。比如有四个元素："John", "Jack", "Camila", "Tom"，他们的优先级值分别为4，3，2，1。  
那么最小优先队列排序应该为："Tom"，"Camila"，"Jack"，"John"。  


### 最大优先队列  
最大优先队列   正好相反，把优先级值最大的元素放置在队列的最前面，以上面的为例，最大优先队列排序应该为："John", "Jack", "Camila", "Tom"。


### 队列的抽象数据类型
队列同样是一种特殊的线性表，其插入和删除的操作分别在表的两端进行，队列的特点就是==先进先出(First In First Out)。==

我们把向队列中插入元素的过程称为入队(Enqueue)，删除元素的过程称为出队(Dequeue)并把允许入队的一端称为队尾，允许出的的一端称为队头，没有任何元素的队列则称为空队。其一般结构如下： 

![image](https://img-blog.csdn.net/20161203180332139)


下面我们就来分别实现顺序队列和链式队列

## 顺序队列的设计与实现  
关于顺序队列（底层都是利用数组作为容器）的实现，我们将采用顺序循环队列的结构来实现，在给出实现方案前先来分析一下为什么不直接使用顺序表作为底层容器来实现。

实际上采用顺序表实现队列时，入队操作直接执行顺序表尾部插入操作，其时间复杂度为O(1)，出队操作直接执行顺序表头部删除操作，其时间复杂度为O(n)，主要用于移动元素，效率低，既然如此，我们就把出队的时间复杂度降为O(1)即可，为此在顺序表中添加一个头指向下标front和尾指向下标，出队和入队时只要改变front、rear的下标指向取值即可，此时无需移动元素，因此出队的时间复杂度也就变为O(1)。其过程如下图所示

![image](https://img-blog.csdn.net/20161203232233493)


## 优先队列
就是元素添加和移除是基于优先级的。就是在原来的排队中在分优先级。现实例子就是医院排队看病，病情严重的优先排在前面进行治疗。

```
let priorityQueue = new PriorityQueue()
priorityQueue.enqueue('John'，2)//添加元素和优先级
priorityQueue.enqueue('Jack'，1)
priorityQueue.enqueue('Camila'，1)//Jack,Camila,John添加完毕队列
```
![image](https://img-blog.csdn.net/20170910223027341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcnRoMzYyMTQ3Nzcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


## 循环队列-击鼓传花
循环队列。现实例子就是击鼓传花(Hot Potato)，在游戏中，孩子们围着圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜利)。


```
let names = ['John','Jack','Camila','Ingrid','Carl'];
let winner = hotPotato(names, 7);
console.log（winner+"胜利者"）
//Camila被淘汰。
//Jack被淘汰。
//Carl被淘汰。
//Ingrid被淘汰。
//John胜利者
```

![image](https://img-blog.csdn.net/20170910223042268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcnRoMzYyMTQ3Nzcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 队列应用的简单举例
- 模拟现实世界中的队列，如售票柜台的队列以及其他先到先服务的场景。
- 计算客户在呼叫中心等待的时间。
- 异步数据的传输（文件输入输出、管道、嵌套字）。
- 操作系统中的优先级任务执行。
- 短信群体发送 应用的发布订阅模式

## 实现一个简单的 Promise 队列

### 思路  
Promise本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。

队列本身要有节流功能，即可以控制同一时间内在运行的Promise数量，参考bluebird的map函数中的concurrency(并发)字段。

实现
比较核心的代码简化起来就这一段：


```
function add(fn) {
  return new Promise((resolve, reject) => {
    this.queue.push(() =>
      Promise.resolve()
        .then(fn)
        .then(resolve, reject)
    );
  });
}
```

可以看到我们是往queue队列里加入了一个函数，这个函数包裹了原函数fn，将它执行的同步或者异步的结果传给外层的Promise，这样对外表现就还是一个Promise，这个函数进入队列，等待轮到它执行的时机

之后就是在内部维护一个“正在运行的任务数量”，在fn运行前后做加减和判断，就可以控制并行数了

完整代码：np-queue

运行起来的感觉类似这样


```
const q = new Queue();
const delay = (value) =>  
  new Promise(resolve => {
    setTimeout(() => resolve(value), 1000);  
  });
q.add(()=>delay(1)).then(console.log);
q.add(()=>delay(2)).then(console.log);
const delay_wrap = q.wrap(delay);
delay_wrap(3).then(console.log);
delay_wrap(4).then(console.log);
```


默认并发数是1，因此代码会相隔1秒依次输出1,2,3,4

放到业务代码上，原代码是delay().then(...)，现在改为q.add(delay).then(...)，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解

再配合wrap()方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：

const wrapFn = function () {
  return queue.add(fn.bind(thisArg, ...arguments));
};
原代码为delay(a,b).then(...)我们可以改为delay_wrap(a,b).then(...)，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。

